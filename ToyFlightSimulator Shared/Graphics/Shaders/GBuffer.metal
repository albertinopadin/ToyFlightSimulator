//
//  GBuffer.metal
//  ToyFlightSimulator
//
//  Created by Albertino Padin on 1/27/23.
//

#include <metal_stdlib>
using namespace metal;

// Include header shared between this Metal shader code and C code executing Metal API commands
#include "TFSShaderTypes.h"

// Include header shared between all Metal shader code files
#include "TFSShaderCommon.h"

#include "Shared.metal"

// Per-vertex inputs fed by vertex buffer laid out with MTLVertexDescriptor in Metal API
typedef struct
{
    float3 position  [[ attribute(TFSVertexAttributePosition) ]];
    float2 tex_coord [[ attribute(TFSVertexAttributeTexcoord) ]];
    half3  normal    [[ attribute(TFSVertexAttributeNormal) ]];
    half3  tangent   [[ attribute(TFSVertexAttributeTangent) ]];
    half3  bitangent [[ attribute(TFSVertexAttributeBitangent) ]];
} DescriptorDefinedVertex;

// Vertex shader outputs and per-fragment inputs.  Includes clip-space position and vertex outputs
// interpolated by rasterizer and fed to each fragment generated by clip-space primitives.
typedef struct
{
    float4 position [[ position ]];
    float4 color;
    float2 tex_coord;
    float3 shadow_coord;
    float3 eye_position;
    half3 tangent;
    half3 bitangent;
    half3 normal;
} ColorInOut;

vertex ColorInOut gbuffer_vertex(VertexIn in [[ stage_in ]],
                                 constant SceneConstants &sceneConstants [[ buffer(TFSBufferIndexSceneConstants) ]],
                                 constant ModelConstants &modelConstants [[ buffer(TFSBufferModelConstants) ]],
                                 constant LightData &lightData [[ buffer(TFSBufferDirectionalLightData) ]])
{
    ColorInOut out;
    out.color = in.color;
    out.tex_coord = in.textureCoordinate;
    
    float4 modelPosition = float4(in.position, 1.0);
    float4 worldPosition = modelConstants.modelMatrix * modelPosition;
    float4 eyePosition = sceneConstants.viewMatrix * worldPosition;
//    float4 eyePosition = sceneConstants.projectionMatrix * sceneConstants.viewMatrix * worldPosition;
    out.position = sceneConstants.projectionMatrix * eyePosition;
//    out.position = sceneConstants.projectionMatrix * sceneConstants.viewMatrix * worldPosition;
    out.eye_position = eyePosition.xyz;
    out.shadow_coord = (lightData.shadowTransformMatrix *
                        lightData.shadowViewProjectionMatrix *
                        worldPosition).xyz;
    
    // Rotate tangents, bitangents, and normals by the normal matrix
//    half3x3 normalMatrix = half3x3(modelConstants.normalMatrix);
//    // Calculate tangent, bitangent and normal in eye's space
//    out.tangent = normalize(normalMatrix * half3(in.tangent));
//    out.bitangent = -normalize(normalMatrix * half3(in.bitangent));
//    out.normal = normalize(normalMatrix * half3(in.normal));
    
//    // Calculate tangent, bitangent and normal in eye's space
//    out.tangent = normalize(half3(modelConstants.normalMatrix * in.tangent));
//    out.bitangent = -normalize(half3(modelConstants.normalMatrix * in.bitangent));
//    out.normal = normalize(half3(modelConstants.normalMatrix * in.normal));
    
    // Calculate tangent, bitangent and normal in eye's space
    out.tangent = half3(normalize(modelConstants.normalMatrix * in.tangent));
    out.bitangent = half3(-normalize(modelConstants.normalMatrix * in.bitangent));
    out.normal = half3(normalize(modelConstants.normalMatrix * in.normal));
    
//    out.tangent = half3(1, 0, 0);
//    out.bitangent = half3(0, 0, 1);
//    out.normal = half3(0, 1, 0);
    
//    float4 tangentWorldPosition = modelConstants.modelMatrix * float4(in.tangent, 1);
//    float4 bitangentWorldPosition = modelConstants.modelMatrix * float4(in.bitangent, 1);
//    float4 normalWorldPosition = modelConstants.modelMatrix * float4(in.normal, 1);
    
//    out.tangent = normalize(half3(tangentWorldPosition.xyz));
//    out.bitangent = -normalize(half3(bitangentWorldPosition.xyz));
//    out.normal = normalize(half3(normalWorldPosition.xyz));
    
//    out.tangent = normalize(normalMatrix * half3(tangentWorldPosition.xyz));
//    out.bitangent = -normalize(normalMatrix * half3(bitangentWorldPosition.xyz));
//    out.normal = normalize(normalMatrix * half3(normalWorldPosition.xyz));

    return out;
}

fragment GBufferData gbuffer_fragment_base(ColorInOut     in        [[ stage_in ]],
                                           depth2d<float> shadowMap [[ texture(TFSTextureIndexShadow) ]])
{
    half4 base_color = half4(in.color);
    half4 normal = half4(in.normal, 1.0);
    half specularContribution = 1.0;  // Hardcoded for base
    
    // Fill in on-chip geometry buffer data
    GBufferData gBuffer;
    
    // Calculate normal in eye space
    half3 tangent_normal = normalize((normal.xyz * 2.0) - 1.0);

    half3 eye_normal = (tangent_normal.x * in.tangent +
                        tangent_normal.y * in.bitangent +
                        tangent_normal.z * in.normal);
    
    eye_normal = normalize(eye_normal);
    
    constexpr sampler shadowSampler(coord::normalized,
                                    filter::linear,
                                    mip_filter::none,
                                    address::clamp_to_edge,
                                    compare_func::less);
    
    // Compare the depth value in the shadow map to the depth value of the fragment in the sun's.
    // frame of reference.  If the sample is occluded, it will be zero.
    float shadow_sample = shadowMap.sample_compare(shadowSampler, in.shadow_coord.xy, in.shadow_coord.z);
    
    // Store shadow with albedo in unused fourth channel
    gBuffer.albedo_specular = half4(base_color.xyz, specularContribution);
    
    // Store the specular contribution with the normal in unused fourth channel.
    gBuffer.normal_shadow = half4(eye_normal.xyz, shadow_sample);
    
    gBuffer.depth = in.eye_position.z;
    
    return gBuffer;
}

fragment GBufferData gbuffer_fragment_material(ColorInOut        in           [[ stage_in ]],
                                               constant Material &material    [[ buffer(TFSBufferIndexMaterial) ]],
                                               sampler           sampler2d    [[ sampler(0) ]],
                                               texture2d<half>   baseColorMap [[ texture(TFSTextureIndexBaseColor) ]],
                                               texture2d<half>   normalMap    [[ texture(TFSTextureIndexNormal) ]],
                                               texture2d<half>   specularMap  [[ texture(TFSTextureIndexSpecular) ]],
                                               depth2d<float>    shadowMap    [[ texture(TFSTextureIndexShadow) ]])
{
    half4 base_color_sample;
    half4 normal_sample;
    half specular_contrib;
    
    if (material.useMaterialColor) {
        base_color_sample = half4(material.color);
    } else if (material.useBaseTexture) {
        base_color_sample = baseColorMap.sample(sampler2d, in.tex_coord.xy);
    }
    
    if (material.useNormalMapTexture) {
        normal_sample = normalMap.sample(sampler2d, in.tex_coord.xy);
    } else {
        normal_sample = half4(in.normal, 1.0);
    }
    
    if (material.useSpecularTexture) {
        specular_contrib = specularMap.sample(sampler2d, in.tex_coord.xy).r;
    } else {
        specular_contrib = 1.0;
    }
    
    // Fill in on-chip geometry buffer data
    GBufferData gBuffer;
    
    // Calculate normal in eye space
    half3 tangent_normal = normalize((normal_sample.xyz * 2.0) - 1.0);
    half3 eye_normal = normalize(tangent_normal.x * in.tangent +
                                 tangent_normal.y * in.bitangent +
                                 tangent_normal.z * in.normal);
    
    constexpr sampler shadowSampler(coord::normalized,
                                    filter::linear,
                                    mip_filter::none,
                                    address::clamp_to_edge,
                                    compare_func::less);
    
    // Compare the depth value in the shadow map to the depth value of the fragment in the sun's.
    // frame of reference.  If the sample is occluded, it will be zero.
    float shadow_sample = shadowMap.sample_compare(shadowSampler, in.shadow_coord.xy, in.shadow_coord.z);
    
    // Store shadow with albedo in unused fourth channel
    gBuffer.albedo_specular = half4(base_color_sample.xyz, specular_contrib);
    
    // Store the specular contribution with the normal in unused fourth channel.
    gBuffer.normal_shadow = half4(eye_normal.xyz, shadow_sample);
    
    gBuffer.depth = in.eye_position.z;
//    gBuffer.depth = in.position.z;
    
    return gBuffer;
}
